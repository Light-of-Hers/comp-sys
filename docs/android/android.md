---
layout: default
title: Android
nav_order: 200
permalink: docs/android
has_children: true
---

# Android

Reference: 

- [Official Guide](https://developer.android.com/guide)
- [Android基础入门教程](https://www.runoob.com/w3cnote/android-tutorial-intro.html)
- Embedded Android: Porting, Extending, and Customizing



First relase in 2008. Despite its licensing, Andoird's development is done mostly behind closed doors.

AOSP effort to get rid of GPL

- Bionic (ASL): replacement for glibc and uClibc
- Toolbox (BSD): replacement for BusyBox
- and others under `external/`

## System

Layer:

- Applications
- Application Framework (e.g. ActivityService, WiFiService)
- Native Layer (e.g., SSL, libc, Dalvik VM, openGL, SQLite)
  - Dalvik VM interprets `.dex` files, while JVM interpret `.class`. The `.dex`s are generated by the `dx` utility using the `.class`s. (avoid any copyright issure involving Oracle)
  - Apache Harmony: a clean-room reimplementation of the Java class library 
- Linux Kernel

## Entry Points

multiple entry points / activities:

- activity: interact with the user
  - When one app invokes another, the calling app invokes an activity in the other app, rather than the app as an atomic whole. In this way, the activity serves as the entry point for an app's interaction with the user.
  - Typically, one activity in an app is specified as the *main activity*, which is the first screen to appear when the user launches the app. 
  - [Life Cycle](https://developer.android.com/guide/components/activities/activity-lifecycle)
- services: run in the background
  - If it is not something the user is directly aware as running, the system may kill the service. Foreground services must display a [Notification](https://developer.android.com/guide/topics/ui/notifiers/notifications.html) `startForeground(1, notificationBuilder.getNotification()) in onCreate()`
  - We can bound a process to a service in another process. `bindService()`. monitor the connection by `ServiceConnection`
  - The service does **not** create its own thread and does **not** run in a separate process unless you specify otherwise.
  - use `IntentService`
    - create a new thread for handling intents
    - intent are processed one by one
- broadcast receivers: e.g. alarm, low battery, ...
- Content provides

```java
Intent intent = new Intent(context, LogActivity.class);  // entry point 
intent.putExtra(key, value);  // and its argv (intent)
startActivityForResult(intent, request_code);

String value = intent.getStringExtra(key); // get argv
setResult(resultCode, intent);

void onActivityResult(int requestCode, int resultCode, Intent data) ...
```

backgroud work:

- Long-running HTTP download: DownloadManager
- Deferrable work: ForegroundService
- Trigger by system events: WorkManager
- Run at precise time: Alarmmanager
- Generic: WorkManager

## Threads Model

UI is handled by a *main thread* (sometimes called *Looper thread*). The Android UI toolkit is *not* thread-safe. So, you must not manipulate your UI from a worker thread—you must do all manipulation to your user interface from the UI thread (i.e. the main thread).

A thread may be associated with a `Looper`, which is a message queue and is often used with `Handler`.

Handler

- bound to the thread / message queue of the thread that is creating it. Therefore, other threads can communicate back with the main application thread through a Handler
- `post()` enqueue Runnable 
- `sendMessage()` processed by Handler's overridden method

Access the UI thread from other threads

- `Activity.runOnUiThread(Runnable)`
- `View.post(Runnable)`
- `Handler`
- `AsyncTask`: `onPreExecute()` -> `doInBackground(Params...)` -> `onProgressUpdate(Progress...)` -> `onPostExecute(Result)` (**deprecated in API level 30**, [why?](https://www.techyourchance.com/asynctask-deprecated/))
  - replacement: `ExecutorService`, `Thread` + `Handler`

```java
public class TaskRunner {
    private final Executor executor = Executors.newSingleThreadExecutor(); // change according to your requirements
    private final Handler handler = new Handler(Looper.getMainLooper());

    public interface Callback<R> {
        void onComplete(R result);
    }

    public <R> void executeAsync(Callable<R> callable, Callback<R> callback) {
        executor.execute(() -> {
            final R result = callable.call();
            handler.post(() -> {
                callback.onComplete(result);
            });
        });
    }
}
```
## flash ROM

reference:

- https://www.howtogeek.com/162516/how-to-flash-your-nexus-s-or-any-other-android-device-with-a-new-rom/

### Step1: recovery image

```
adb reboot bootloader # fastboot mode
```

recovery image: A bootable program on an Android flash memory partition that is used to perform a factory reset or restore the original OS version. In order to install a different OS version (a different ROM), the stock recovery image must be replaced with a custom version such as **ClockworkMod Recovery**. After rooting the Android, utilities such as **ROM Manager** install the custom recovery.

After install the custom image (recovery.img), enter recover mode.

```
adb reboot recovery
```

### Step2: ROM

Android ROM (not read-only-memory): A file containing the executable instructions (a system image) of an Android OS and affiliated apps.

- stock ROM: comes installed on the phone
- custom ROM: comes from a third party

Flashing the ROM:  installing the system image into the device's internal flash memory. Flash memory holds the Android's firmware.

- update.zip
  - System.img: Android OS, affiliated apps
  - Boot.img: 
    - kernel
    - rootfs

